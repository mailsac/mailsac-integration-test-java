package com.mailsac.api;

import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.junit.jupiter.api.Assertions.fail;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.AfterAll;

import java.util.Properties;

import javax.mail.Session;
import javax.mail.internet.MimeMessage;
import javax.mail.Transport;
import javax.mail.Message;
import javax.mail.MessagingException;
import javax.mail.internet.MimeMessage;
import javax.mail.internet.InternetAddress;

import com.mashape.unirest.http.HttpResponse;
import com.mashape.unirest.http.Unirest;
import com.mashape.unirest.http.exceptions.UnirestException;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.JsonNode;

import java.io.IOException;

public class AppTest {

    // Generated by mailsac. See https://mailsac.com/api-keys
    static String mailsacAPIKey = "";
    // Mailsac email address where the email will be sent
    static String mailsacToAddress = "";
    // Username for smtp server authentication
    static String smtpUser = "";
    // Password for smtp server authentication
    static String smtpPassword = "";
    // Hostname of the smtp server
    static String smtpHost = "";
    // Port the smtp is listening on
    static int smtpPort = 587;

    @AfterAll
    static void purgeInbox() throws UnirestException {
        Unirest.delete(String.format("https://mailsac.com/api/addresses/%s/messages", mailsacToAddress))
            .header("Mailsac-Key", mailsacAPIKey)
            .asString();
    }

    @Test
    void sendMail() throws MessagingException, UnirestException, IOException, InterruptedException {
        // Set system property for mail.mime.address.usecanonicalhostname to false because DNS lookup is expensive
        Properties properties = new Properties();
        properties.setProperty("mail.mime.address.usecanonicalhostname", "false");

        // Collect property which will prevent message.setFrom() from triggering a call to the local address (some network configurations causes the InetAddress.getCanonicalHostName to be slow)
        Session session = Session.getInstance(properties);

        // Construct message
        MimeMessage message = new MimeMessage(session);
        message.setFrom(new InternetAddress(smtpUser));
        message.setRecipients(Message.RecipientType.TO, InternetAddress.parse(mailsacToAddress));
        message.setSubject("Hello!");
        message.setText("Check out https://example.com");
        message.setContent("Check out <a href='https://example.com'>My website</a>", "text/plain");

        // Construct transport with proper authentication information then send message
        Transport transport = session.getTransport("smtp");
        transport.connect(smtpHost, smtpPort, smtpUser, smtpPassword);
        message.saveChanges();
        transport.sendMessage(message, message.getAllRecipients());

        // Check inbox for the message 10x every 5 seconds then break out of block if message is found
        found: {
            for (int i = 0; i < 10; i++) {
                // Send request to fetch a JSON array of email message objects from mailsac
                HttpResponse<String> response = Unirest.get(String.format("https://mailsac.com/api/addresses/%s/messages", mailsacToAddress))
                    .header("Mailsac-Key", mailsacAPIKey)
                    .asString();

                // Parse JSON
                ObjectMapper objectMapper = new ObjectMapper();
                Object[] array = objectMapper.readValue(response.getBody(), Object[].class);

                if (array.length > 0) {
                    // Convert object into JSON to fetch a field
                    JsonNode jsonNode = objectMapper.convertValue(array[0], JsonNode.class);

                    // After a message is found, the JSON object is checked to see if the link was sent correctly
                    assertTrue(jsonNode.get("links").toString().contains("https://example.com"), "Missing / Incorrect link in email");
                    break found;
                }
                
                Thread.sleep(5000);
            }

            // Fail the test if for loop does not break
            fail("Never received messages!");
        }
    }

}
